#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Tested with Loxone Miniserver version 16.0.6.10

import struct
import ftplib
import binascii
import StringIO
import sys

loxoneMiniServerIP = '192.168.178.200'  # IP address of the Loxone Miniserver
adminUsername = '<<ADMIN USER>>'
adminPassword = '<<ADMIN PASSWORD>>'

if adminUsername == '<<ADMIN USER>>':
    print("Enter the correct IP addres of your Miniserver, the admin username and password in the script!")
    sys.exit(1)

def RSHash(key):
    # it seems a and b are switched by Loxone
    a = 63689
    hash = 0
    for i in range(len(key)):
        hash = hash * a + ord(key[i])
        hash = hash & 0xFFFFFFFF
        a = a * 378551
    return hash
def JSHash(key):
    hash = 1315423911
    for i in range(len(key)):
        hash ^= (hash >> 2) + ord(key[i]) + (hash * 32)
        hash = hash & 0xFFFFFFFF
    return hash
def DJBHash(key):
    hash = 5381
    for i in range(len(key)):
        hash += hash * 32 + ord(key[i])
        hash = hash & 0xFFFFFFFF
    return hash
def DEKHash(key):
    hash = len(key)
    for i in range(len(key)):
        hash = ((hash << 5) ^ (hash >> 27)) ^ ord(key[i])
        hash = hash & 0xFFFFFFFF
    return hash

ftp = ftplib.FTP(loxoneMiniServerIP)
ftp.login(adminUsername, adminPassword)

ftp.cwd('update')

# get the firmware version number from the first .upd file
files = []
ftp.retrlines('NLST', files.append)  # Get just filenames
# Parse filenames from directory listing if needed
clean_files = []
for f in files:
    if f.endswith('.upd'):
        # Extract just the filename from full listing format
        filename = f.split()[-1] if ' ' in f else f
        clean_files.append(filename)

if not clean_files:
    print("No .upd files found!")
    ftp.quit()
    sys.exit(1)

version = clean_files[0].split('_')[0]
print("Detected version: %s" % version)
print("Target file: %s_B1E1424BFF667AF471D715EE6745FDF0.upd" % version)

# Load DigitalInputTree update into a buffer
sio = StringIO.StringIO()
def handle_binary(more_data):
    sio.write(more_data)
ftp.retrbinary("RETR %s_B1E1424BFF667AF471D715EE6745FDF0.upd" % version, callback=handle_binary)
filedata = sio.getvalue()

ftp.quit()

offset = filedata.rfind(binascii.unhexlify('A55A39')) # first 3 bytes of the master device ID
if offset >= 0:
    filedata = filedata[offset:]
    encryptedAESKey = filedata[12+16*3:12+16*4]
    encryptedAESIV = filedata[12+16*1:12+16*2]
    CryptoCanAlgoKey = [DEKHash(encryptedAESKey), JSHash(encryptedAESKey), DJBHash(encryptedAESKey), RSHash(encryptedAESKey)]
    CryptoCanAlgoIV = [DEKHash(encryptedAESIV), JSHash(encryptedAESIV), DJBHash(encryptedAESIV), RSHash(encryptedAESIV)]

    f = open('LoxoneAESKeys.py', 'w')
    f.write('# The AES key/IV is generated by 4 hash functions from this data:\n')
    f.write('LoxoneCryptoEncryptedAESKey = "%s"\n' % binascii.hexlify(encryptedAESKey))
    f.write('LoxoneCryptoEncryptedAESIV = "%s"\n' % binascii.hexlify(encryptedAESIV))
    f.write('\n')
    f.write('LoxoneCryptoCanAlgoLegacyKey = [ %#08x, %#08x, %#08x, %#08x ]\n' % struct.unpack('<LLLL', filedata[12+16*2:12+16*3]))
    f.write('LoxoneCryptoCanAlgoLegacyIV = [ %#08x, %#08x, %#08x, %#08x ]\n' % struct.unpack('<LLLL', filedata[12+16*0:12+16*1]))
    f.write('\n')
    f.write('LoxoneCryptoMasterDeviceID = "%s"\n' % binascii.hexlify(filedata[0:12]))
    f.close()
